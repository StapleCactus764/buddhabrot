<!DOCTYPE html>
<html>
<!--
Started: 4/2/2024, 10:52AM
Working prototype: 4/3/2024, 10:54PM

Try to convert everything into GPU
 - Probably can do it with convert. Just pass things in
 - Try to figure out if update can be converted. Maybe
   change perspective to be pixel-based, rather than
   z based
 - What about directly rendering the points? Take the
   position, get the pixel behind it and draw that plus
   1
 - Probably do two passes, one for the first .xy and one
   for .zw

THIS IS STILL ALL ONLY HALF OF ALL POINTS
 -->
<head>
    <title>Buddhabrot</title>
    <style>
        * {
            margin: 0;
            /* overflow: hidden; */
        }

        canvas {
            position: absolute;
            top: 0;
            background-color: black;
            transform: rotate(90deg);
        }

        #stats {
            position: absolute;

            margin: 5px;

            font-family: monospace;
        }


        /* button {
            position: relative;

            z-index: 10;
        } */
    </style>
</head>

<body>
    <div id='stats'>
        Status: <span id='status'>idle</span><br>
        Iterations: <span id='iterations'></span><br>
        Frame: <span id='frame'>0</span><br>
        Last MSPF: <span id='mspf'>null</span><br>
    </div>

    <script src='https://cdn.jsdelivr.net/gh/staplecactus764/webgl-compute-shader@v1.0.5/main.js'></script>
    
    <script id='points-vs' type='glsl'>
attribute float id;

uniform sampler2D zArr;
uniform vec2 zArrDim;

uniform sampler2D bArr;
uniform vec2 bArrDim;

uniform vec2 screenSize;
uniform float scale;
uniform vec2 offset; // Order normal

varying float bounded;

vec2 idToTex(float id) {
    return (vec2(mod(id, zArrDim.x), floor(id / zArrDim.x)) + 0.5) / zArrDim;
}

void main() {
    vec2 texPos = idToTex(id);

    vec2 pos = texture2D(zArr, texPos).xy * scale - offset + screenSize / 2.0; // * vec2(screenSize.y / screenSize.x, 1)
    vec2 totalPos = (floor(pos * 2.0)) / screenSize;
    vec2 screenPos = totalPos - 1.0;

    bounded = texture2D(bArr, texPos).x;
    
    gl_PointSize = 1.0;
    gl_Position = vec4(screenPos, 0, 1);
}
    </script>
    <script id='points-fs' type='glsl'>
precision highp float;

uniform sampler2D result;
uniform vec2 resultDim;

varying float bounded;

void main() {
    float val = texture2D(result, gl_FragCoord.xy / resultDim).x;
    
    gl_FragColor = vec4(val + bounded, 0, 0, 1);
}
    </script>

    <script id='clear' type='glsl'>
precision highp float;

void main() {
    gl_FragColor = vec4(0, 0, 0, 0);
}

    </script>

    <script id='copy' type='glsl'>
precision highp float;

uniform sampler2D result;
uniform vec2 resultDim;

void main() {
    gl_FragColor = texture2D(result, gl_FragCoord.xy / resultDim);
}
    </script>


    <script id='step' type='glsl'>
precision highp float;

uniform sampler2D zArr;
uniform vec2 zArrDim;
uniform sampler2D cArr;
uniform vec2 cArrDim;

vec2 csquare(vec2 a) {
    return vec2(a.x * a.x - a.y * a.y, 2.0 * a.x * a.y);
}
float dsq(vec2 a) {
    return a.x * a.x + a.y * a.y;
}

void main() {
    vec4 z = texture2D(zArr, gl_FragCoord.xy / zArrDim);
    vec4 c = texture2D(cArr, gl_FragCoord.xy / cArrDim);

    vec2 p1 = csquare(z.xy) + c.xy,
        p2 = csquare(z.zw) + c.zw;
    if (dsq(p1) >= 100.0) p1 = vec2(100, 100);
    if (dsq(p2) >= 100.0) p2 = vec2(100, 100);

    gl_FragColor = vec4(p1, p2);
}
    </script>

    <!-- Checks which points are still bounded -->
    <script id='check' type='glsl'>
precision highp float;

uniform sampler2D zArr;
uniform vec2 zArrDim;

float dsq(vec2 a) {
    return a.x * a.x + a.y * a.y;
} 

void main() {
    vec4 z = texture2D(zArr, gl_FragCoord.xy / zArrDim);


    vec2 half1 = vec2(0, 0),
        half2 = vec2(0, 0);
    //if (z.x == 100.0 && z.y == 100.0)
    //    half1 = vec2(1, 1);
    //if (z.z == 100.0 && z.w == 100.0)
    //    half2 = vec2(1, 1);

    if (dsq(z.xy) >= 4.0) half1 = vec2(1, 1);
    if (dsq(z.zw) >= 4.0) half2 = vec2(1, 1);

    gl_FragColor = vec4(half1, half2);
}
    </script>

    <script id='display' type='glsl'>
precision highp float;

uniform sampler2D result;
uniform vec2 resultDim;

uniform float max;

void main() {
    gl_FragColor = vec4(texture2D(result, gl_FragCoord.xy / resultDim).xxx / max, 1);
}
    </script>
    

    <script>

let wakeLock;
const getWakeLock = async () => {
    try {
        wakeLock = await navigator.wakeLock.request("screen");
        // console.log('Wake lock active');
    } catch (e) {
        console.log(e);
    }
};
getWakeLock();

document.addEventListener('visibilitychange', () => {
    if (!document.hidden) getWakeLock();
});

const cgl = {canvas: document.createElement('canvas')};
cgl.context = cgl.canvas.getContext('webgl', {
    powerPreference: 'high-performance',
    antialias: false,
});
glCanvas = cgl.canvas,
gl = cgl.context;
ComputeShader.useContext(cgl);

document.body.append(glCanvas);

const iter = 1_000_000;
    // iterChunkSize = 100,
    // iterChunks = (iter / iterChunkSize | 0) + 1;

const width = 5 * 100, // 5 * 400
    height = 4 * 100; // 4 * 400
const pw = 200,
    ph = 200;
const scale = Math.min(width, height) / 400 * 110;
const offsetx = 0,
    offsety = Math.max(width, height) / 500 * -60;

glCanvas.width = width;
glCanvas.height = height;

glCanvas.style.left = -(Math.max(width - height, 0) / 2 | 0) + 'px';
glCanvas.style.top = (Math.max(width - height, 0) / 2 | 0) + 'px';

stats.style.top = width + 'px';


const zArr = new Float32Array(pw * ph * 4),
    zTestArr = new Float32Array(pw * ph * 4),
    cArr = new Float32Array(pw * ph * 4); // Bounded

const z = new ComputeShaderInput('zArr', zArr, pw, ph),
    c = new ComputeShaderInput('cArr', cArr, pw, ph),
    b = new ComputeShaderInput('bArr', new Float32Array(pw * ph * 4), pw, ph)
    r = new ComputeShaderInput('result', new Float32Array(width * height * 4), width, height),
    tr = new ComputeShaderInput('result', new Float32Array(width * height * 4), width, height),
    maxu = new ComputeShaderUniform('max', '1f', 0);

const genRandom = () => {
    for (let y = 0; y < ph; y ++) {
        for (let x = 0; x < pw; x ++) {
            const index = (y * pw + x) * 4;

            // Order of offsets is swapped
            cArr[index    ] = (Math.random() * width  - width  / 2 + offsety) / scale;// (x       - pw / 2 + offsety) / scale;
            cArr[index + 1] = (Math.random() * height - height / 2 + offsetx) / scale;// (y       - ph / 2 + offsetx) / scale;
            cArr[index + 2] = (Math.random() * width  - width  / 2 + offsety) / scale;// (x + 0.5 - pw / 2 + offsety) / scale;
            cArr[index + 3] = (Math.random() * height - height / 2 + offsetx) / scale;// (y + 0.5 - ph / 2 + offsetx) / scale;
        }
    }

    c.update(cArr);
};

const clearShader = new ComputeShader(document.getElementById('clear').textContent, pw, ph);
const clear = shader => {
    clearShader.use();
    clearShader.run();
    ComputeShader.swap(clearShader.output, shader);
};

const copyShader = new ComputeShader(document.getElementById('copy').textContent, width, height);
copyShader.use();
copyShader.addInput(r);
copyShader.initializeInputs();

const copy = shader => {
    copyShader.use();
    copyShader.initializeInputs();
    copyShader.run();
    ComputeShader.swap(copyShader.output, shader);
};

const stepShader = new ComputeShader(document.getElementById('step').textContent, pw, ph);
stepShader.use();
stepShader.addInput(z);
stepShader.addInput(c);
stepShader.initializeInputs();

const checkShader = new ComputeShader(document.getElementById('check').textContent, pw, ph);
checkShader.use();
checkShader.addInput(z);
checkShader.addInput(c);
checkShader.initializeInputs();

const displayShader = new ComputeShader(document.getElementById('display').textContent, width, height);
displayShader.use(true);
displayShader.addInput(r);
displayShader.addUniform(maxu);
displayShader.initializeInputs();
displayShader.initializeUniforms();

const step = () => {
    stepShader.use();
    stepShader.initializeInputs();
    stepShader.run();
    ComputeShader.swap(stepShader.output, z);
};

const check = () => {
    checkShader.use();
    checkShader.initializeInputs();
    checkShader.run();
    ComputeShader.swap(checkShader.output, b);
};

const pvs = ComputeShader.createShader(gl, gl.VERTEX_SHADER, document.getElementById('points-vs').textContent),
    pfs = ComputeShader.createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('points-fs').textContent);

const idAttrib = 10;
const pointsProgram = (() => {
    const program = gl.createProgram();
    gl.attachShader(program, pvs);
    gl.attachShader(program, pfs);

    gl.bindAttribLocation(program, idAttrib, 'id');

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new ComputeShaderError('An error occured in a program: ' + gl.getProgramInfoLog(program));
    }

    return program;
})();

const zArrUniform = gl.getUniformLocation(pointsProgram, 'zArr'),
    zArrDimUniform = gl.getUniformLocation(pointsProgram, 'zArrDim'),
    screenSizeUniform = gl.getUniformLocation(pointsProgram, 'screenSize'),
    scaleUniform = gl.getUniformLocation(pointsProgram, 'scale'),
    offsetUniform = gl.getUniformLocation(pointsProgram, 'offset'),
    resultUniform = gl.getUniformLocation(pointsProgram, 'result'),
    resultDimUniform = gl.getUniformLocation(pointsProgram, 'resultDim'),
    bArrUniform = gl.getUniformLocation(pointsProgram, 'bArr'),
    bArrDimUniform = gl.getUniformLocation(pointsProgram, 'bArrDim');

gl.useProgram(pointsProgram);

const numPoints = pw * ph,
    pointIds = new Float32Array(numPoints);
for (let i = 0; i < numPoints; i ++) pointIds[i] = i;

gl.enableVertexAttribArray(idAttrib);

const idBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);
gl.bufferData(gl.ARRAY_BUFFER, pointIds, gl.STATIC_DRAW);

gl.vertexAttribPointer(idAttrib, 1, gl.FLOAT, false, 0, 0);

gl.uniform2fv(screenSizeUniform, [width, height]);
gl.uniform1f(scaleUniform, scale);
gl.uniform2fv(offsetUniform, [offsety, offsetx]); // Order reversed


const update = () => {
    // Use
    gl.useProgram(pointsProgram);

    gl.bindFramebuffer(gl.FRAMEBUFFER, tr.frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tr.texture, 0);

    // Initialize inputs
    gl.uniform1i(zArrUniform, 0);
    gl.uniform2fv(zArrDimUniform, [pw, ph]);

    gl.uniform1i(resultUniform, 1);
    gl.uniform2fv(resultDimUniform, [width, height]);

    gl.uniform1i(bArrUniform, 2);
    gl.uniform2fv(bArrDimUniform, [pw, ph]);

    // Run
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, z.texture);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, r.texture);

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, b.texture);

    gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);

    gl.viewport(0, 0, width, height);

    gl.drawArrays(gl.POINTS, 0, numPoints);

    ComputeShader.swap(tr, r);

    copy(tr);
};
const display = () => {
    const hits = r.read();
    let max = 0;
    for (let i = 0; i < hits.length; i += 4) {
        if (hits[i] > max) max = hits[i];
    }

    maxu.update(max);

    displayShader.use(true);
    displayShader.initializeInputs();
    displayShader.initializeUniforms();
    displayShader.run();

};


const status = document.getElementById('status'),
    mspf = document.getElementById('mspf'),
    iterations = document.getElementById('iterations'),
    frame = document.getElementById('frame');

iterations.textContent = new Intl.NumberFormat('en-US').format(iter);

let lastDisplay = performance.now(),
    frames = 0;
const loop = () => {
    const start = performance.now();

    genRandom();
    clear(z);
    
    for (let i = iter; i --;) step();

    check();
    clear(z);

    for (let i = iter; i --;) {
        step();
        update();
    }

    const end = performance.now();
    if (end - lastDisplay > 5000) {
        display();
        lastDisplay = performance.now();
    }
    mspf.textContent = (end - start | 0) + 'ms';

    frames ++;
    frame.textContent = frames;
};

let toggle = false;
let interval = 0;
document.addEventListener('mousedown', e => {
    if (e.button === 2) return;

    status.textContent = toggle ? 'idle' : 'running';


    if (toggle) window.clearInterval(interval);
    else interval = window.setInterval(loop, 1);
    toggle = !toggle;
});

    </script>
</body>

</html>